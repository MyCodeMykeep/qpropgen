#!/usr/bin/env python3
import argparse
import os
import sys

import yaml

from jinja2 import Environment, PackageLoader


__appname__ = 'qpropgen'
__version__ = '0.1.0'
__license__ = 'Apache 2.0'

DESCRIPTION = """\
Generate QML property-based headers and implementation
"""

NO_CONST_REF_ARG_TYPES = {'int', 'bool', 'qreal'}

AUTOGENERATED_DISCLAIMER = 'This file has been generated with qpropgen, any' \
    ' changes made to it will be lost!'

HEADER_EXT = '.h'
IMPL_EXT = '.cpp'


def get_filename_we(filepath):
    filename = os.path.basename(filepath)
    return os.path.splitext(filename)[0]


def generate_file(template, out_path, class_def, properties):
    args = dict(
        autogenerated_disclaimer=AUTOGENERATED_DISCLAIMER,
        class_name=class_def['class']['name'],
        header=class_def['header'],
        properties=properties,
    )

    with open(out_path, 'w') as f:
        f.write(template.render(**args))


def complete_class_def(class_def, filename_we):
    """Adds extra fields to class_def"""
    class_def['header'] = filename_we + HEADER_EXT
    return class_def


def complete_property_def(property_def):
    """Adds extra fields to property_def"""
    camelcase_name = property_def['name'][0].upper() + property_def['name'][1:]

    property_def.setdefault('setter_name', 'set' + camelcase_name)

    type_ = property_def['type']
    need_constref = type_ not in NO_CONST_REF_ARG_TYPES and type_[-1] != '*'
    if need_constref:
        arg_type = 'const {}&'.format(type_)
    else:
        arg_type = type_
    property_def.setdefault('arg_type', arg_type)

    property_def.setdefault('var_name', 'm' + camelcase_name)

    return property_def


def main():
    parser = argparse.ArgumentParser()
    parser.description = DESCRIPTION

    parser.add_argument('-d', '--directory', dest='directory',
                        default='.',
                        help='generate files in DIR', metavar='DIR')

    parser.add_argument('class_definition')

    args = parser.parse_args()

    with open(args.class_definition, 'r') as f:
        class_def = yaml.load(f)
    filename_we = get_filename_we(args.class_definition)

    class_def = complete_class_def(class_def, filename_we)
    properties = [complete_property_def(x) for x in class_def['properties']]

    env = Environment(loader=PackageLoader('qpropgen', 'templates'))

    for ext in HEADER_EXT, IMPL_EXT:
        out_path = os.path.join(args.directory, filename_we + ext)
        template = env.get_template('template{}'.format(ext))
        generate_file(template, out_path, class_def, properties)

    return 0


if __name__ == '__main__':
    sys.exit(main())
# vi: ts=4 sw=4 et
